{
  "language": "Solidity",
  "sources": {
    "contracts/NFTSocial.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract NFTSocial {\n\n    event PostCreated (bytes32 indexed postId, address indexed postOwner, bytes32 indexed parentId, bytes32 contentId, bytes32 categoryId);\n    event ContentAdded (bytes32 indexed contentId, string contentUri);\n    event CategoryCreated (bytes32 indexed categoryId, string category);\n    event Voted (bytes32 indexed postId, address indexed postOwner, address indexed voter, uint80 reputationPostOwner, uint80 reputationVoter, int40 postVotes, bool up, uint8 reputationAmount);\n\n    // Data structure for each post\n    struct post {\n        address postOwner;\n        bytes32 parentPost; // used to implement comments as a child of each post\n        bytes32 contentId;\n        int40 votes;\n        bytes32 categoryId;\n    }\n\n    mapping (address => mapping (bytes32 => uint80)) reputationRegistry; // mapping user address to a mapping of categoryId to category name (categoryRegistry)\n    mapping (bytes32 => string) categoryRegistry; // mapping categoryId to the category name\n    mapping (bytes32 => string) contentRegistry; // mapping the contentId to the url in IPFS\n    mapping (bytes32 => post) postRegistry; // mapping the postId to the post data structure\n    mapping (address => mapping (bytes32 => bool)) voteRegistry; // mapping user address to a mapping of voteId to a boolean (like/dislike => true/false)\n\n    // Function to create a post based on the post struct data structure defined above\n    function createPost(bytes32 _parentId, string calldata _contentUri, bytes32 _categoryId) external { // content URI is where the post data is stored in IPFS\n        address _owner = msg.sender;\n        bytes32 _contentId = keccak256(abi.encode(_contentUri)); // create contentId by hashing the _contentUri\n        bytes32 _postId = keccak256(abi.encodePacked(_owner, _parentId, _contentId)); // postId comprised of the hash of owner, parentId, contentId\n        contentRegistry[_contentId] = _contentUri; // save the contentUri to the contentRegistry mapping\n        postRegistry[_postId].postOwner = _owner;\n        postRegistry[_postId].parentPost = _parentId;\n        postRegistry[_postId].contentId = _contentId;\n        postRegistry[_postId].categoryId = _categoryId;\n        // postRegistry[_postId].votes = 0; (Not needed bc Solidity auto initialized ints to 0)\n        emit ContentAdded(_contentId, _contentUri); // event to notify that the content was IPFS, used to fetch data on front end\n        emit PostCreated (_postId, _owner,_parentId,_contentId,_categoryId); // fire event that post was created\n    }\n\n    // Function to add a \"like\" or \"upvote\" to another user's post\n    function voteUp(bytes32 _postId, uint8 _reputationAdded) external { // _reputationAdded adds to the reputation of the _voter in specific category\n        address _voter = msg.sender;\n        bytes32 _category = postRegistry[_postId].categoryId;\n        address _contributor = postRegistry[_postId].postOwner;\n        require (postRegistry[_postId].postOwner != _voter, \"User cannot vote their own posts\");\n        require (voteRegistry[_voter][_postId] == false, \"User already voted on this post\");\n        require (validateReputationChange(_voter,_category,_reputationAdded) == true, \"This address cannot add this amount of reputation points\");\n        postRegistry[_postId].votes += 1; // increments the vote count of the specific post voted on\n        reputationRegistry[_contributor][_category] += _reputationAdded; // increments to reputation of the user\n        voteRegistry[_voter][_postId] = true; // saves voteRegistry as state and changes to true so the user can't vote twice\n        emit Voted(_postId, _contributor, _voter, reputationRegistry[_contributor][_category], reputationRegistry[_voter][_category], postRegistry[_postId].votes, true, _reputationAdded); // collects all voting data to be used to update UI\n    }\n\n    // Function to add a \"dislike\" or \"downvote\" to another user's post\n    function voteDown(bytes32 _postId, uint8 _reputationTaken) external {\n        address _voter = msg.sender;\n        bytes32 _category = postRegistry[_postId].categoryId;\n        address _contributor = postRegistry[_postId].postOwner;\n        require (voteRegistry[_voter][_postId] == false, \"User cannot vote their own posts\");\n        require (validateReputationChange(_voter,_category,_reputationTaken)==true, \"This address cannot take this amount of reputation points\");\n        postRegistry[_postId].votes >= 1 ? postRegistry[_postId].votes -= 1 : postRegistry[_postId].votes = 0; // only decrement if user's votes are > 1; i.e. a post cannot have negative votes!\n        reputationRegistry[_contributor][_category] >= _reputationTaken ? reputationRegistry[_contributor][_category] -= _reputationTaken: reputationRegistry[_contributor][_category] =0;\n        voteRegistry[_voter][_postId] = true;\n        emit Voted(_postId, _contributor, _voter, reputationRegistry[_contributor][_category], reputationRegistry[_voter][_category], postRegistry[_postId].votes, false, _reputationTaken);\n    }\n\n    // Function to validate the change in user reputation\n    function validateReputationChange(address _sender, bytes32 _categoryId, uint8 _reputationAdded) internal view returns (bool _result){\n        uint80 _reputation = reputationRegistry[_sender][_categoryId];\n        if (_reputation < 2 ) { // if the reputation of the user voting is less than 2\n            _reputationAdded == 1 ? _result = true : _result = false; // the reputation added will only be one\n        }\n        else { // if reputation is greater than 2\n            2**_reputationAdded <= _reputation ? _result = true: _result = false; // we logarithmically determine the reputation added\n        }\n    }\n\n    // Function to add a new category for posts / discussion\n    function addCategory(string calldata _category) external {\n        bytes32 _categoryId = keccak256(abi.encode(_category));\n        categoryRegistry[_categoryId] = _category;\n        emit CategoryCreated(_categoryId, _category);\n    }\n\n    /* GET FUNCTIONS */\n\n    function getContent(bytes32 _contentId) public view returns (string memory) {\n        return contentRegistry[_contentId];\n    }\n    \n    function getCategory(bytes32 _categoryId) public view returns(string memory) {   \n        return categoryRegistry[_categoryId];\n    }\n\n    function getReputation(address _address, bytes32 _categoryID) public view returns(uint80) {   \n        return reputationRegistry[_address][_categoryID];\n    }\n\n    function getPost(bytes32 _postId) public view returns(address, bytes32, bytes32, int72, bytes32) {   \n        return (\n            postRegistry[_postId].postOwner,\n            postRegistry[_postId].parentPost,\n            postRegistry[_postId].contentId,\n            postRegistry[_postId].votes,\n            postRegistry[_postId].categoryId);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}